import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import fs from "fs"; // Use standard fs
import path from "path";
// We don't need checkCodeQuality here as it's run via package.json script

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
Author: Eric Rhys Taylor
*/
`;

const prod = process.argv[2] === "production";

// --- Read README content --- START ---
// Note: This reads the README but doesn't actively use it in the build artifact
// It's included here to match the timeline project's structure
const readmePath = path.resolve('README.md'); // Get absolute path to README
let readmeContent = '';
try {
	readmeContent = fs.readFileSync(readmePath, 'utf-8');
	console.log('Read README.md for embedding.'); // Log matches timeline project
} catch (err) {
	console.error('Failed to read README.md for embedding:', err);
	readmeContent = 'Error: Could not load README content.'; // Fallback content
}
// --- Read README content --- END ---

// Define source and destination paths
const sourceDir = "."; // Project root
const destDirs = [
	"/Users/erictaylor/Documents/Author/Book Trisan Series/Trisan Obsidian Vault .nosync/.obsidian/plugins/manuscript-calendar", // Updated plugin name
	"/Users/erictaylor/Documents/Code Projects/Test Obsidian Vault/.obsidian/plugins/manuscript-calendar" // Updated plugin name
];

// Files to copy (manifest and styles from root)
const filesToCopy = [
	"manifest.json",
	"styles.css"
];

// Function to copy build assets to destination directories (mirrors timeline logic)
async function copyBuildAssets() {
	const isCI = !!process.env.CI; // Check if in CI environment

	// --- Copy manifest.json and styles.css from root ---
	for (const destDir of destDirs) {
		if (!isCI) { // Only perform fs operations if not in CI
			if (!fs.existsSync(destDir)) {
				try {
					fs.mkdirSync(destDir, { recursive: true });
				} catch (mkdirErr) {
					console.error(`âœ— Error creating directory ${destDir}:`, mkdirErr);
					continue; // Skip this destination if directory creation fails
				}
			}
			for (const file of filesToCopy) {
				const sourcePath = path.join(sourceDir, file);
				const destPath = path.join(destDir, file);
				if (fs.existsSync(sourcePath)) {
					try {
						fs.copyFileSync(sourcePath, destPath);
					} catch (err) {
						console.error(`Error copying ${file} to ${destDir}:`, err);
					}
				} else {
					console.warn(`Warning: Source file ${sourcePath} does not exist, skipping.`);
				}
			}
		}
	}

	// --- Copy main.js from first vault to others (only if not in CI) ---
	const mainJsSourcePath = path.join(destDirs[0], "main.js");
	if (!isCI && fs.existsSync(mainJsSourcePath)) {
		for (let i = 1; i < destDirs.length; i++) {
			const destDir = destDirs[i];
			const mainJsDestPath = path.join(destDir, "main.js");
			// Ensure target directory exists (might have been skipped if creation failed earlier)
			if (fs.existsSync(destDir)) { 
				try {
					fs.copyFileSync(mainJsSourcePath, mainJsDestPath);
				} catch (err) {
					console.error(`Error copying main.js to ${destDir}:`, err);
				}
			}
		}
	}

	// Always log the target directories message
	console.log(`Build assets copied to: ${destDirs.join(", ")}`);
}

// --- esbuild Context ---
const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ['main.ts'],
	bundle: true,
	external: [
		'obsidian',
		'electron',
		// Removed codemirror v5 externals, add v6 if needed
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtins,
	],
	format: 'cjs',
	target: 'es2018',
	logLevel: 'info',
	sourcemap: prod ? false : 'inline',
	treeShaking: true,
	outdir: destDirs[0], // Build directly into the first vault directory
	// Define is optional unless your code actually uses EMBEDDED_README_CONTENT
	// define: { 'EMBEDDED_README_CONTENT': JSON.stringify(readmeContent) }
}).catch((e) => {
	console.error("esbuild context creation failed:", e);
	process.exit(1);
});

// --- Build/Watch Logic ---
if (prod) {
	// --- Production Build ---
	try {
		await context.rebuild();
		// Copy assets AFTER build completes
		await copyBuildAssets(); // Logs targets, copies locally if not CI
		console.log("Production build complete!");
	} catch (buildErr) {
		console.error("Production build failed:", buildErr);
		process.exit(1);
	} finally {
		process.exit(0); // Ensure exit even if copyBuildAssets has issues logging
	}

} else {
	// --- Development Watch ---
	try {
		await context.watch();
		// Copy files initially on watch start
		await copyBuildAssets(); // Logs targets, copies locally
		console.log("Watching for changes...");
	} catch (watchErr) {
		 console.error("Failed to start watch mode:", watchErr);
		 process.exit(1);
	}
	
	// --- Watcher for manifest.json and styles.css ---
	filesToCopy.forEach(file => {
		const sourcePath = path.join(sourceDir, file);
		try {
			fs.watch(sourcePath, async () => {
				console.log(`${file} changed, copying to vaults...`);
				await copyBuildAssets(); // Re-run copy logic for simplicity
			});
		} catch (watchErr) {
			console.error(`Failed to watch ${file}:`, watchErr);
		}
	});

	// --- Watcher for main.js in the output directory ---
	// Note: esbuild's watch should trigger rebuilds. We only need to copy
	// the result from the first vault to others AFTER esbuild rebuilds.
	// esbuild context's onEnd hook might be cleaner, but let's mirror the timeline setup.
	const mainJsOutputPath = path.join(destDirs[0], "main.js");
	try {
		fs.watch(mainJsOutputPath, async () => {
			console.log(`main.js rebuilt, copying to other vaults...`);
			// Call copyBuildAssets again to propagate main.js and log
			// This is slightly redundant but mirrors the structure provided
			await copyBuildAssets(); 
		});
	} catch (watchErr) {
		console.error(`Failed to watch ${mainJsOutputPath}:`, watchErr);
	}
}
